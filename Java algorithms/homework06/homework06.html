<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Рекурсия</title>
    <style type="text/css">
        body {
            margin: 50pt;
            font-family: 'Times New Roman', Times, serif; /* Гарнитура текста */
            font-size: 14pt;
        }
    </style>
</head>
<body>
<p>Задания 6.1
    <br>Приведите пример использования древовидной структуры.
<p>Примером древовидной структуры являются: генеалогическое древо, биологическое древо видов,
    файловая система на жестком диске.
<hr>
<p>Задание 6.2
    <br>Реализуйте класс узла дерева и базовый шаблон дерева с базовыми методами.
<p>Реализация в листинге программы.
<hr>
<p>Задание 6.3
    <br>Реализуйте методы поиска и вставки узла в дерево.
<p>Реализация в листинге программы.
<hr>
<p>Задание 6.4
    <br>Реализуйте базовые методы обхода дерева и метода дисплей.
    <br>Реализуйте поиск максимума и минимума.
<p>Реализация в листинге программы.
<hr>
<p>Задание 6.5
    <br>Реализуйте метод удаления узла и выполните оценку времени базовых методов дерева с помощью System.nanoTime().
<hr>
<p>Задание 6.6
    <br>Реализуйте на основе массива из задания 2.1 алгоритм пирамидальной сортировки с реализацией бинарной пирамиды.
    <br>Выполните оценку алгоритма пирамидальной сортировки с помощью System.nanoTime() и сравните с предыдущими
    алгоритмами сортировки.
<p>Реализация в листинге программы. Время сортировки больше чем в предыдущих случаях.
<hr>
<p>Задание 6.7
    <br>Приведите пример сбалансированного дерева и его применения.
<p>Дерево является балансированным в следующем смысле: для любого узла дерева высота его правого поддерева
    отличается от высоты левого поддерева не более чем на единицу.
    <br>Самобалансирующиеся двоичные деревья поиска — неплохая структура данных для реализации ассоциативных массивов,
    очередей с приоритетами, и, в первую очередь, множеств, где важно упорядочение элементов.
    Главная сильная черта деревьев поиска — гибкость в плане области применения, т.к. нельзя сказать,
    что для любой задачи деревья поиска обеспечат лучшую производительность, чем специализированные структуры.
<hr>
<p>Листинг программы:
    <a href="https://github.com/S1aks/Homeworks/blob/master/Java%20algorithms/homework06/src/com/hw/Main.java">
        https://github.com/S1aks/Homeworks/blob/master/Java%20algorithms/homework06/src/com/hw/Main.java</a>
<p>Результат вывода программы:
<pre><code>
Задание 6.1
Приведите пример использования древовидной структуры.:

Примером древовидной структуры являются: генеалогическое древо,
биологическое древо видов, файловая система на жестком диске.
---------------------------------------------------------------------
Задания 6.2 - 6.5
Реализация класса узла дерева и дерева с базовыми методами. А так же оценка времени
 работы базовых методов дерева с помощью System.nanoTime():

Добавление Person #0 ⚠ Время выполнения: 1553400 наносекунд
Добавление Person #1 ⚠ Время выполнения: 4900 наносекунд
Добавление Person #2 ⚠ Время выполнения: 1500 наносекунд
Добавление Person #3 ⚠ Время выполнения: 1200 наносекунд
Добавление Person #4 ⚠ Время выполнения: 900 наносекунд
Добавление Person #5 ⚠ Время выполнения: 900 наносекунд
Добавление Person #6 ⚠ Время выполнения: 900 наносекунд
Добавление Person #7 ⚠ Время выполнения: 800 наносекунд
Добавление Person #8 ⚠ Время выполнения: 1000 наносекунд
Добавление Person #9 ⚠ Время выполнения: 1000 наносекунд

Поиск Person #8 ⚠ Время выполнения: 12100 наносекунд

Минимальный Id: 0 ⚠ Время выполнения: 23300 наносекунд

Максимальный Id: 14 ⚠ Время выполнения: 15000 наносекунд

Печать дерева:
ID: 0, Name: Person #5
ID: 10, Name: Person #6
ID: 11, Name: Person #9
ID: 12, Name: Person #8
ID: 13, Name: Person #2
ID: 13, Name: Person #7
ID: 14, Name: Person #0
ID: 14, Name: Person #4
ID: 17, Name: Person #1
ID: 17, Name: Person #3
Печать дерева закончена. ⚠ Время выполнения: 14776900 наносекунд

Удаление узла с Id = 10 ⚠ Время выполнения: 11400 наносекунд
Результат:
ID: 0, Name: Person #5
ID: 11, Name: Person #9
ID: 12, Name: Person #8
ID: 13, Name: Person #2
ID: 13, Name: Person #7
ID: 14, Name: Person #0
ID: 14, Name: Person #4
ID: 17, Name: Person #1
ID: 17, Name: Person #3
---------------------------------------------------------------------
Задание 6.6
Реализация на основе массива из задания 2.1 алгоритма пирамидальной
 сортировки с реализацией бинарной пирамиды:

Начальный массив:
[11, 17, 7, 6, 15, 14, 14, 14, 0, 14, 6, 19, 4, 2, 13, 1, 11, 11, 3, 12]
Сортировка.. ⚠ Время выполнения: 1630700 наносекунд
Конечный массив:
[0, 1, 2, 3, 4, 6, 6, 7, 11, 11, 11, 12, 13, 14, 14, 14, 14, 15, 17, 19]
---------------------------------------------------------------------
Задание 6.7
Приведите пример сбалансированного дерева и его применения:

Дерево является балансированным в следующем смысле: для любого узла дерева высота его правого поддерева
    отличается от высоты левого поддерева не более чем на единицу.
Самобалансирующиеся двоичные деревья поиска — неплохая структура данных для реализации ассоциативных массивов,
    очередей с приоритетами, и, в первую очередь, множеств, где важно упорядочение элементов.
Главная сильная черта деревьев поиска — гибкость в плане области применения, т.к. нельзя сказать,
    что для любой задачи деревья поиска обеспечат лучшую производительность, чем специализированные структуры.

Process finished with exit code 0
</code></pre>
</body>
</html>