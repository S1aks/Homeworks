<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Рекурсия</title>
    <style type="text/css">
        body {
            margin: 50pt;
            font-family: 'Times New Roman', Times, serif; /* Гарнитура текста */
            font-size: 14pt;
        }
    </style>
</head>
<body>
<p>Задание 5.1
    <br>Приведите пример использования рекурсии.
<p>Пример рекурсии в математике - факториал. Пример рекурсии в жизни - резонанс.
<hr>
<p>Задание 5.2
    <br>Реализуйте простой пример бесконечной рекурсии и обычной рекурсии с условием для выхода.
<p>Бесконечная рекурсия:
<pre><code>
    public static int recursionInfinite(int element) {
        System.out.println(element);
        return recursionInfinite(element - 1);
    }
</code></pre>
<p>Рекурсия с условием выхода:
<pre><code>
    public static int recursionFinite(int element) {
        System.out.println(element);
        if (element > 0) {
            return recursionFinite(element - 1);
        } else {
            return 0;
        }
    }
</code></pre>
<hr>
<p>Задание 5.3
    <br>Приведите пример изображающий стек вызова и стек вызова с рекурсией.
<p>Стек вызовов — это стек, хранящий в себе информацию для возврата управления из методов
    в программу или метод (вызвавший очередной метод).
    <br>При вызове метода в стек заносится адрес возврата — адрес в памяти следующей инструкции
    после вызова метода, а управление передается вызванному методу.
    <br>При последующем вложенном или рекурсивном вызове в стек заносится очередной адрес возврата и так далее.
    <br>При возврате из метода адрес возврата берется со стека, и управление передается на него.
<hr>
<p>Задание 5.4
    <br>Реализуйте простой алгоритм использующий цикл и простой алгоритм использующий рекурсию.
    <br>Оцените два алгоритма с помощью базового метода System.nanoTime().
<p>Решение в листинге программы.
<hr>
<p>Задание 5.5
    <br>Реализуйте алгоритм двоичного рекурсивного поиска на основе массива из задания 2.1.
    <br>Оцените алгоритм двоичного рекурсивного поиска с помощью базового метода System.nanoTime()
    и сравните с обычным двоичным поиском.
<p>Решение в листинге программы.
<hr>
<p>Задание 5.6
    <br>На основе массива из задания 2.1 реализуйте алгоритм сортировки слиянием.
    <br>Оцените алгоритм сортировки слиянием с помощью базового метода System.nanoTime()
    и сравните с сортировкой методом sort().
<p>Решение в листинге программы.
<hr>
<p>Листинг программы:
    <a href="https://github.com/S1aks/Homeworks/blob/master/Java%20algorithms/homework05/src/com/hw/Main.java">
        https://github.com/S1aks/Homeworks/blob/master/Java%20algorithms/homework05/src/com/hw/Main.java</a>
<p>Результат вывода программы:
<pre><code>
Задания 5.1 - 5.3 описаны в файле HTML к проекту. Вызовы методов есть в теле класса.
---------------------------------------------------------------------
Задание 5.4
Реализация простого алгоритма циклом и рекурсивным методом:
Факториал числа 10 циклом = 3628800 ⚠ Время выполнения: 49300 наносекунд
Факториал числа 10 методом = 3628800 ⚠ Время выполнения: 22700 наносекунд
---------------------------------------------------------------------
Задание 5.5
Реализация алгоритма двоичного рекурсивного поиска на основе массива:
[0, 1, 2, 3, 4, 6, 6, 7, 11, 11, 11, 12, 13, 14, 14, 14, 14, 15, 17, 19]
Двоичный поиск числа 15 циклом: Индекс - 17 ⚠ Время выполнения: 21700 наносекунд
Двоичный поиск числа 15 методом: Индекс - 17 ⚠ Время выполнения: 15600 наносекунд
---------------------------------------------------------------------
Задание 5.6
Реализация алгоритма сортировки слиянием на основе массива:
[11, 17, 7, 6, 15, 14, 14, 14, 0, 14, 6, 19, 4, 2, 13, 1, 11, 11, 3, 12]
Сортировка слиянием:
[0, 1, 2, 3, 4, 6, 6, 7, 11, 11, 11, 12, 13, 14, 14, 14, 14, 15, 17, 19]
 ⚠ Время выполнения: 76200 наносекунд
Сортировка массива методом Arrays.sort():
[0, 1, 2, 3, 4, 6, 6, 7, 11, 11, 11, 12, 13, 14, 14, 14, 14, 15, 17, 19]
 ⚠ Время выполнения: 54000 наносекунд

Process finished with exit code 0
</code></pre>
</body>
</html>